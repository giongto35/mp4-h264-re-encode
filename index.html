<html>
<script src="mp4box.all.min.js"></script>
<script src="mp4wasm.js"></script>
<script>

async function reencode(file) {
  let timeToUpdateCurrentTime = 0;
  let timeToCreateImageBitmap = 0;
  let timeToEncodeBitmap = 0;
  let timeToMP4Mux = 0;

  let decoder;

  let totalSampleCount = 0;
  let fps = 0;
  let width = 0;
  let height = 0;
  let duration = 0;

  const MP4BoxFile = MP4Box.createFile();
  MP4BoxFile.onError = error => console.error(error);
  MP4BoxFile.onReady = async (info) => {
    console.log(info);
    const track = info.videoTracks[0];
    totalSampleCount = track.nb_samples;
    fps = (track.nb_samples / track.movie_duration) * 1000;
    width = track.track_width;
    height = track.track_height;
    duration = track.movie_duration;

    let description;
    const trak = MP4BoxFile.getTrackById(track.id);
    for (const entry of trak.mdia.minf.stbl.stsd.entries) {
      if (entry.avcC || entry.hvcC) {
        const stream = new DataStream(undefined, 0, DataStream.BIG_ENDIAN);
        if (entry.avcC) {
          entry.avcC.write(stream);
        } else {
          entry.hvcC.write(stream);
        }
        description = new Uint8Array(stream.buffer, 8); // Remove the box header.
        break;
      }
    }

    const MP4 = await new MP4Wasm();

    const outputFile = createVirtualFile();
    const mux = MP4.create_muxer(
      {
        width,
        height,
        fps,
        fragmentation: false,
        sequential: false,
        hevc: false,
      },
      function mux_write(data_ptr, size, offset) {
        // seek to byte offset in file
        outputFile.seek(offset);
        // get subarray of memory we are writing
        const data = MP4.HEAPU8.subarray(data_ptr, data_ptr + size);
        // write into virtual file
        return outputFile.write(data) !== data.byteLength;
      }
    );

    decoder = new VideoDecoder({
      async output(frame) {
        timeToUpdateCurrentTime += performance.now() - now; now = performance.now();
        const bitmap = await createImageBitmap(frame);
        timeToCreateImageBitmap += performance.now() - now; now = performance.now();

        const timestamp = frame.timestamp; // (1 / fps) * frameIndex * 1000000;
        const groupOfPictures = 20;
        const keyFrame = frameIndex % groupOfPictures === 0;
        let videoFrame = new VideoFrame(bitmap, { timestamp });
        encoder.encode(videoFrame, { keyFrame });
        videoFrame.close();

        const flushFrequency = 10;
        if ((frameIndex + 1) % flushFrequency === 0) {
          await encoder.flush();
        }
        frameIndex++;

        progress.innerText = 
          "Encoding frame " + frameIndex + " (" + Math.round(100 * currentTime / duration) + "%) at " +
          Math.round(1000 * frameIndex / (performance.now() - startNow)) + " fps";


        const total = timeToUpdateCurrentTime + timeToCreateImageBitmap + timeToEncodeBitmap + timeToMP4Mux;

        console.log({
          timeToUpdateCurrentTime: timeToUpdateCurrentTime / total * 100,
          timeToCreateImageBitmap: timeToCreateImageBitmap / total * 100,
          timeToEncodeBitmap: timeToEncodeBitmap / total * 100,
          timeToMP4Mux: timeToMP4Mux / total * 100,
        });

        frame.close();

        if (frameIndex === totalSampleCount - 2) {
          await encoder.flush();
          encoder.close();

          MP4.finalize_muxer(mux);
          const data = outputFile.contents();

          const url = URL.createObjectURL(new Blob([data], { type: "video/mp4" }));
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = "download.mp4";
          anchor.click();

          const seconds = (performance.now() - startNow) / 1000;
          progress.innerText = 
            "Encoded in " + frameIndex + " frames in " + Math.round(seconds) + "s at " +
            Math.round(frameIndex / seconds) + " fps";
        }
      },
      error(error) {
        console.log(error);
      }
    });

    decoder.configure({
      codec: track.codec,
      codedHeight: track.video.height,
      codedWidth: track.video.width,
      description,
    });

    const encoder = new window.VideoEncoder({
      output(chunk) {
        timeToEncodeBitmap += performance.now() - now; now = performance.now();

        const uint8 = new Uint8Array(chunk.byteLength);
        chunk.copyTo(uint8);
        const p = MP4._malloc(uint8.byteLength);
        MP4.HEAPU8.set(uint8, p);
        MP4.mux_nal(mux, p, uint8.byteLength);
        MP4._free(p);
        timeToMP4Mux += performance.now() - now; now = performance.now();
      },
      error(error) {
        console.error(error);
      }
    });

    encoder.configure({
      codec: 'avc1.4d0034',
      width: width,
      height: height,
      avc: {
        format: 'annexb',
      },
      hardwareAcceleration: 'prefer-hardware',
      bitrate: 9_000_000,
    });

    MP4BoxFile.setExtractionOptions(track.id);
    MP4BoxFile.start();
  };
  MP4BoxFile.onSamples = (track_id, ref, samples) => {
    // Generate and emit an EncodedVideoChunk for each demuxed sample.
    for (const sample of samples) {
      decoder.decode(new EncodedVideoChunk({
        type: sample.is_sync ? "key" : "delta",
        timestamp: 1e6 * sample.cts / sample.timescale,
        duration: 1e6 * sample.duration / sample.timescale,
        data: sample.data
      }));
    }
  };

  let currentTime = 0;
  let frameIndex = 0;
  const startNow = performance.now();
  let now = performance.now();

  var reader = new FileReader();
  reader.onload = function() {
    this.result.fileStart = 0;
    MP4BoxFile.appendBuffer(this.result);
    MP4BoxFile.flush();
  };
  reader.readAsArrayBuffer(file);
}

function createVirtualFile(initialCapacity = 1024 * 1024) {
  let cursor = 0;
  let usedBytes = 0;
  let contents = new Uint8Array(initialCapacity);
  return {
    contents: function () {
      return contents.slice(0, usedBytes);
    },
    seek: function (offset) {
      // offset in bytes
      cursor = offset;
    },
    write: function (data) {
      const size = data.byteLength;
      expand(cursor + size);
      contents.set(data, cursor);
      cursor += size;
      usedBytes = Math.max(usedBytes, cursor);
      return size;
    },
  };

  function expand(newCapacity) {
    var prevCapacity = contents.length;
    if (prevCapacity >= newCapacity) {
      return; // No need to expand, the storage was already large enough.
    }
    newCapacity = Math.max(newCapacity, (prevCapacity * 2.0) >>> 0);
    const oldContents = contents;
    contents = new Uint8Array(newCapacity); // Allocate new storage.
    if (usedBytes > 0) {
      contents.set(oldContents.subarray(0, usedBytes), 0);
    }
  }
}
</script>

<p>
  Select a video to re-encode:
  <input type="file" onchange="reencode(event.target.files[0])"></input>
  <div id="progress"></div>
</p>
